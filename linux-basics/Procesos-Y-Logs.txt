PS, Top y Kill
Ps -> process status
Ps -e -> nos devuelve todos los procesos
Ps aux -> nos devuelve los procesos con mas información
Ps aux | grep nombreProceso -> busca un proceso

TOP -> table of processes 
Top -> trae informacion del numero de procesos 

P → ordenar por CPU

M → ordenar por memoria

k → matar proceso

q → salir


Kill
kill PID -> Envía señal SIGTERM (15) → apagado limpio

kill -9 PID-> SIGKILL (9) → fuerza bruta`  



Grep
Grep -i ->case insensitive, busca sin importar mayúsculas o minúsculas  

Revisar la memoria y almacenamiento
lsblk → lista de dispositivos y tamaño
df -h revisar el almacenamiento


free -h revisar memoria

Columnas importantes

used → memoria usada por programas

free → memoria libre

available → memoria realmente disponible para nuevos procesos (mejor indicador que free)

Script para la memoria ram:
umbral=1000  # en MB
libre=$(free -m | awk 'NR==2 {print $7}')  # columna 'available' y la -m es para mmostrar memoria en MB

if [ $libre -lt $umbral ]; then
    echo "Atención: poca memoria disponible ($libre MB)"
else
    echo "Memoria suficiente: $libre MB"
fi

Script para uso del disco:
uso=$(df -h / | awk 'NR==2 {print $5}')
echo "El uso del disco en / es $uso"

du → “disk usage” (uso de carpetas y archivos)
du -sh /home/usuario

-s → resumen (no lista todos los subdirectorios)
-h → human readable

Alerta por disco lleno:

umbral=80
uso=$(df / | awk 'NR==2 {gsub("%","",$5); print $5}')

if [ $uso -ge $umbral ]; then
    echo "Cuidado: la partición / está al $uso% de uso"
else
    echo "Espacio suficiente: $uso%"
fi

gsub("%","",$5)

gsub = global substitute

Reemplaza todos los % en la columna $5 por nada ("").

$5 = columna Use%, que normalmente tiene un % al final, por ejemplo 42%

Resultado: solo 42 (número puro).

df / → mira solo la partición raíz (/).

awk 'NR==2 {gsub("%","",$5); print $5}' → extrae el porcentaje usado, sin %.

uso=$(...) → guarda ese valor en una variable para usarlo en tu script.

La diagonal / no es un “comodín”, es literal: significa la partición raíz.
Si quisieras revisar otra carpeta, podrías poner /home o /var en lugar de /.

Logs
var/log

tail -f /var/log/nginx/error.log
grep -i error archivo.log

☐	Busca archivos que contengan una palabra específica
grep -ri "palabra" /ruta/del/directorio

La F es para que siga corriendo el comando y no solo muestre las ultimas lineas 

Archivo	Qué guarda
syslog / messages	   Eventos generales del sistema
auth.log	           Logins, sudo, ssh
kern.log	           Mensajes del kernel
dmesg			           Arranque del sistema
nginx/			         Logs de Nginx
apache2/		         Logs de Apache

Estados de los procesos:
R running/runnable esta usando cpu o esta listo y esperando turno
S sleeping, esperando un evento
D uninterruptible sleep, no responde a kill -9 
T stopped/traced, proceso detenido
Z zombie, proceso terminado pero no limpiado por parte del padre 


Systemctl
systemctl status ssh -> te da el status del ssh

Acción	     Comando
Estado SSH-> systemctl status ssh
Iniciar->    systemctl start ssh
Reiniciar->  systemctl restart ssh
Recargar->   systemctl reload ssh
Logs->       journalctl -u ssh
Arranque->   systemctl enable ssh




journalctl -u ssh -> ver logs
journalctl -u nginx
journalctl -u docker
journalctl -u mysql
journalctl -u ssh -f
-f = follow (tiempo real)
sustituto de tail journalctl -u ssh -n 20


Logs

SERVICIO="ssh"
LOG="/var/log/check_service.log"
FECHA=$(date "+%Y-%m-%d %H:%M:%S")

if systemctl is-active --quiet "$SERVICIO"; then
    echo "$FECHA - $SERVICIO está activo" >> "$LOG"
else
    echo "$FECHA - ERROR: $SERVICIO NO está activo" >> "$LOG"
fi

>> redirige la salida estándar (stdout) de un comando y la AÑADE a un archivo.

Ejemplo:

echo "Hola" >> archivo.txt


 Lo que normalmente verías en pantalla con echo
 se escribe al final de archivo.txt

 Diferencia clave: > vs >>
>
echo "Hola" > archivo.txt
Borra el contenido anterior


>>
echo "Hola" >> archivo.txt

Conserva lo que ya existe

Añade al final (append)

Para logs, SIEMPRE >> 
